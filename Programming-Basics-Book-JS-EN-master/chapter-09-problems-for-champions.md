# Chapter 9.1. Problems for Champions – Part I

In this chapter, we will offer the reader a few **more difficult tasks** that aim to develop **algorithmic skills** and acquire **programming techniques** to solve tasks with higher complexity.

## More Complex Problems on The Studied Material

We will solve together several programming problems that cover the material studied in the book, but are more difficult than the usual problems of the practical exams at SoftUni. If you want to become a **champion on the basics of programming**, we recommend this training to solve such complex tasks to make it easy for you to take exams.


## Problem: Crossing Sequences

We have two sequences:
   - **a sequence of Tribonacci** (by analogy with the Fibonacci sequence), where each number is **the sum of the previous three** (with given three numbers)
   - a sequence generated by a **numerical spiral** defined by looping like a spiral (right, bottom, left, top, right, bottom, left, top, etc.) of a matrix of numbers starting from its center with a given starting number and incremental step, by storing the current numbers in the sequence each time we make a turn.

Write a program that finds the first number that appears **in both sequences defined in an aforementioned way**.

### Problem

Let **the Tribonacci sequence** start with **1**, **2** and **3**. This means that **the first sequence** will contain the numbers 1, 2, 3, 6, 11, 20, 37, 68, 125, 230, 423, 778, 1431, 2632, 4841, 8904, 16377, 30122, 55403, 101902, and so on.

At the same time, let the **numbers in the spiral** begin with **5**, and the spiral increases by **2** at each step.

<img src="assets/chapter-9-1-images/01.Crossing-sequences-01.png" style="float: right; height: 300px;" />

Then **the second sequence** will contain the numbers 5, 7, 9, 13, 17, 23, 29, 37, and so on. We see that **37** is the first number to be found in the Tribonacci sequence and the spiral one, and that is the desired solution to the problem.

### Input Data

As parameters of the function, we pass **5 integers**.
   * The first **three parameters** will represent **the first three numbers** in the Tribonacci sequence, positive non-zero numbers, sorted in ascending order.
   * The next **two parameters** are representing **the first number** and **the step** for each cell of the matrix for the spiral of numbers. Numbers representing the spiral are positive non-zero numbers.

Input data will always be valid and will always be in the format described. There is no need to check.

### Output Data

The result should be printed on the console.

On the single line of the output, we must print **the smallest number that occurs in both sequences**. If there is no number in the range [**1 … 1 000 000**], that can be found in both sequences, then print "**No**".

### Constraints

* All numbers in the input will be in the range [**1 … 1 000 000**].
* Allowed program time: 0.3 seconds.
* Allowed memory: 16 MB.

### Sample Input and Output

| Input                      | Output | Input                     | Output | Input                     | Output |
| ------------------------- | ----- | ------------------------ | ----- | ------------------------ | ----- |
| 1<br>2<br>3<br>5<br>2<br> | 37    | 13<br>25<br>99<br>5<br>2 | 13    | 99<br>99<br>99<br>2<br>2 | No    |

| Input                  | Output | Input                   | Output |
| --------------------- | ----- | ---------------------- | ----- |
| 1<br>1<br>1<br>1<br>1 | 1     | 1<br>4<br>7<br>23<br>3 | 23    |

### Hints and Guidelines

The problem seems quite complicated, so we will break it into simpler sub-problems.

#### Processing The Input

The first step in solving the problem is to read and process the input. Input data consists of **5 integers**: **3** for the Tribonacci sequence and **2** for the numerical spiral:

![](/assets/chapter-9-1-images/01.Crossing-sequences-02.png)

Once we have the input data, we need to think about how we will generate the numbers in the two sequences.

#### Generating Tribonacci Sequence

For the Tribonacci sequence, we will always **collect the previous three values** and then move the values of those numbers (the three previous ones) to one position in the sequence, i.e. the value of the first one must accept the value of the second one, and so on. When we are done with the number, we will store its value in **an array**. Since the problem description states that the numbers in the sequences do not exceed 1,000,000, we can stop generating this range at exactly 1,000,000:

![](/assets/chapter-9-1-images/01.Crossing-sequences-03.png)

#### Generating Numerical Spiral

We need to think of **a relationship** between numbers in the numerical spiral so we can easily generate every next number without having to look at matrices and loop through them. If we carefully look at the picture from the description, we will notice that **every 2 "turns" in the spiral, the numbers we skip are increased by 1**, i.e. from *5 to 7* and from *7 to 9*, not a single number is skipped, but we directly **add with the step** of the sequence. From *9 to 13* and from *13 to 17* we skip a number, i.e. we add the step twice. From *17 to 23* and from *23 to 29* we skip two numbers, i.e. we add the step three times and so on.

Thus, we see that for the first two we have **`the last number + 1 * the step`**, the next two we add with the **`2 * the step`** and so on. Every time we want to get to the next number of the spiral, we will have to make such calculations:

![](/assets/chapter-9-1-images/01.Crossing-sequences-04.png)

What we have to take care of is **for every two numbers, our multiplier** (let's call it "coefficient") **must increase by 1** (**` spiralStepMul++`**), which can be achieved with a simple check (**`spiralCount % 2 == 0`**). The whole code from the generation of the spiral in **an array** is given below:

![](/assets/chapter-9-1-images/01.Crossing-sequences-05.png)

#### Finding Common Number for The Sequences

Once we have generated the numbers in both sequences, we can proceed to unite them and build the final solution. How will it look? For **each of the numbers** in the first sequence (starting from the smaller one) we will check if it exists in the other one. The first number that meets this criterion will be **the answer** to the problem.

We will do a **linear** search in the second array, and we will leave the more curious participants to optimize it using the technique called **binary search** because the second array is generated in sorted form, i.e. it meets the requirement to apply this type of search. The code for finding our solution will look like this:

![](/assets/chapter-9-1-images/01.Crossing-sequences-06.png)

The solution to the problem uses arrays to store the values. Arrays are not needed to solve the problem. There is an **alternative solution** that generates the numbers and works directly with them instead of keeping them in an array. On **every step**, we can check whether **the numbers in the two sequences match**. If this is the case, we will print the number on the console and terminate the execution of our program. Otherwise, we will see the current number of **which sequence is the smaller one and we will generate the next one where we are "lagging"**. The idea is that **we will generate numbers from the sequence that is "behind"** until we skip the current number of the other sequence and then vice versa, and if we find a match in the meantime, we will terminate the execution:

![](/assets/chapter-9-1-images/01.Crossing-sequences-07.png)

### Testing in The Judge System

Test your solution here: [https://judge.softuni.org/Contests/Practice/Index/941#0](https://judge.softuni.org/Contests/Practice/Index/941#0).


## Problem: Magic Dates

**Date** is given in a "**dd-mm-yyyy**" format, e.g. 17-04-2018. We calculate **the weight of that date** by taking all of its digits, multiplying each digit with the others after it, and finally summing up all the results obtained. In our case, we have 8 digits: **17032007**, so the weight is **`1*7 + 1*0 + 1*3 + 1*2 + 1*0 + 1*0 + 1*7`** **+** **`7*0 + 7*3 + 7*2 + 7*0 + 7*0 + 7*7`** **+** **`0*3 + 0*2 + 0*0 + 0*0 + 0*7`** **+** **`3*2 + 3*0 + 3*0 + 3*7`** **+** **`2*0 + 2*0 + 2*7`** **+** **`0*0 + 0*7`** **+** **`0*7`** = **144**.

Our task is to write a program that finds all the **magical dates between two specific years (inclusively) corresponding to the given weight**. Dates must be printed in ascending order (by date) in the format "**dd-mm-yyyy**". We will only use the valid dates in the traditional calendar (the leap years have 29 days in February).

### Input Data

Input data consists of 3 lines:

* The first integer: **start year**.
* The second integer: **end year**.
* The third integer: **the search weight** for the dates.

Input data will always be valid and will always be in the format described. There is no need to check.

### Output Data

The result should be printed on the console as consecutive dates in **"dd-mm-yyyy" format**, sorted by date in ascending order. Each string must be in a separate line. If there are no existing magic dates, print "**No**".

### Constraints

* The start and final years are integer numbers in the range [**1900 … 2100**].
* Magic weight is an integer in the range [**1 … 1000**].
* Allowed program time: 0.25 seconds.
* Allowed memory: 16 MB.

### Sample Input and Output

| Input                | Output                                  | Input                     | Output |
| ------------------- | -------------------------------------- | ------------------------ | ----- |
| 2007<br>2007<br>144 | 17-03-2007<br>13-07-2007<br>31-07-2007 | 2003<br>2004<br>1500<br> | No    |

| Input               | Output                                    | Input                   | Output                                    |
| ------------------ | ---------------------------------------- | ---------------------- | ---------------------------------------- |
| 2012<br>2014<br>80 | 09-01-2013<br>17-01-2013<br>23-03-2013<br>11-07-2013<br>01-09-2013<br>10-09-2013<br>09-10-2013<br>17-10-2013<br>07-11-2013<br>24-11-2013<br>14-12-2013<br>23-11-2014<br>13-12-2014<br>31-12-2014 | 2011<br>2012<br>14<br> | 01-01-2011<br>10-01-2011<br>01-10-2011<br>10-10-2011 |

### Hints and Guidelines

We start with the input data. In this case, we have **3 integers**:

![](/assets/chapter-9-1-images/02.Magic-dates-01.png)

Having the start and the end year, it is nice to know how we will go through every date, not to worry about how many days there are in the month and whether it is a leap year, and so on.

#### Loop Through Dates

For looping through the dates, we will take advantage of the functionality that gives us the **`Date`** object in **JavaScript**. We will define a **start date variable** that we can do using the constructor that accepts a year, month, and day. We know the year is the starting year we read from the console and the month and the day must be January and 1st respectively. In JavaScript, the "constructor" of **`Date`** accepts as the first argument the year, as second argument the month (0 is January, 11 is December) and as the third argument the day of the month:

![](/assets/chapter-9-1-images/02.Magic-dates-02.png)

Once we have the start date, we want to create a **loop that runs until we exceed the final year** (or until we pass December 31 in the final year if we compare the full dates), increasing each day by 1 day.

To increase by one day in each rotation, we will use a method of **`Date` - `setDate(…)`**, which will add one day to the current date. The method will take care instead of us, to decide where to skip the next month, how many days there is a month, and everything around the leap years:

![](/assets/chapter-9-1-images/02.Magic-dates-03.png)

In JavaScript, we have to use the method **`getFullYear()`** to get the year in the same format as it is in the input data. If we use the method **`getYear()`** we will get the number of years passed from 1900 until the searched data, which will not help us with our problem. In conclusion, our loop should look like that:

![](/assets/chapter-9-1-images/02.Magic-dates-04.png)

**Caution**: we can do the same thing using **`for` loop**, the initialization of the date will be in the first past of the **`for`**, the condition stays the same, and the step is incremented with one day.

#### Calculating Date Weight

Each date consists of exactly **8 characters (digits)** – **2 for the day** (**`d1`**, **`d2`**), **2 for the month** (**`d3`**, **`d4`**), and **4 for the year** (**`d5`** to **`d8`**). This means that we will always have the same calculation every time, and we can benefit from this **to define the formula statically** (i.e. not to use loops, referring to different numbers from the date, but write the whole formula). To be able to write it, we will need **all digits from the date** in individual variables to make all the necessary multiplications. By using the division and partition operations on the individual components of the date, using the **`getDay()`**, **`getMonth()`**, and **`getFullYear()`** methods, we can retrieve each digit. We have to pay attention to **`getMonth()`**, because the method returns a number between 0 (January) and 11 (December) and we have to add **+1**, to get the months between **`[1-12]`**. Another thing that we have to be careful with is the division by 10 (**`/ 10`**), which won't be an integer division, that's why after each operation we have to round specifically to the lowest integer number by using **`Math.floor(…)`**:

![](/assets/chapter-9-1-images/02.Magic-dates-05.png)

Let's also explain one of the more interesting lines here. Let's take the second digit of the year for example (**`d6`**). We divide the year by 100, and we take a remainder of 10. What do we do? First, we eliminate the last 2 digits of the year by dividing by 100 (Example: **`2018/100 = 20`**). With the remainder of 10, we take the last digit of the resulting number (**`20 % 10 = 0`**) and so we get 0, which is the second digit of 2018.

What remains is to do the calculation that will give us the magical weight of a given date. **To not write all multiplications** as shown in the example, we will simply apply a **grouping**. What we need to do is multiply each digit with those that follow it. Instead of typing **`d1 * d2 + d1 * d3 + … + d1 * d8`**, we can shorten this expression to **`d1 * (d2 + d3 + … + d8)`** for grouping when we have multiplication and summing up. Applying the same simplification for the other multiplications, we get the following formula:

![](/assets/chapter-9-1-images/02.Magic-dates-06.png)

#### Printing The Output

Once we have the weight calculated for a given date, we need **to check and see if it matches the magical weight we want**, to know if it should be printed or not. Checking can be done using a standard **`if`** block, taking care to print the date in the correct format. Fortunately, we already have each one of the digits that we need to print **`d1`** until **`d8`**. Here we have to be careful with the data types. Since the concatenation of strings and the summation are done by the same operator, we have to convert numbers to strings or start the concatenation with an empty string: 

![](/assets/chapter-9-1-images/02.Magic-dates-07.png)

**Caution**: as we go through the dates from the start year to the end one, they will always be arranged in ascending order as per the description.

Finally, if we have not found an eligible date, we will have a **`false`** value in the **`found`** variable and we will be able to print **`No`**:

![](/assets/chapter-9-1-images/02.Magic-dates-08.png)

### Testing in The Judge System

Test your solution here: [https://judge.softuni.org/Contests/Practice/Index/941#1](https://judge.softuni.org/Contests/Practice/Index/941#1).


## Problem: Five Special Letters

Two numbers are given: **start** and **end**. Write a program that **generates all combinations of 5 letters**, each among the sets of **`{'a', 'b', 'c', 'd', 'e'}`** so that the weight of these 5 letters is a number in the range **`[start … end]`**, inclusive. Print them in alphabetical order, in a single row, separated by a space.

**The weight of the letters** is calculated as follows:

```JavaScript 
weight('a') = 5;
weight('b') = -12;
weight('c') = 47;
weight('d') = 7;
weight('e') = -32;
```

**The weight of the sequence** of the letters **`c1, c2, …, cn`** is calculated by removing all the letters that are repeated (from right to left) and then calculating the formula:

```JavaScript 
weight(c1, c2, …, cn) = 1 * weight(c1) + 2 * weight(c2) + … + n * weight(cn)
```

**For example**, the weight of **`bcddc`** is calculated as follows:

First, **we remove the repeating letters** and get **`bcd`**. Then we apply the formula: **`1 * weight('b') + 2 * weight('c') + 3 * weight('d') = 1 * (-12) + 2 * 47 + 3 * 7 = 103`**.

**Another example**: **`weight("cadae") = weight("cade") = 1 * 47 + 2 * 5 + 3 * 7 + 4 * (-32) = -50`**.

### Input Data

The input data is read from the console. It consists of two numbers:
* The number for a **start**.
 The number for an **end**.

Input data will always be valid and will always be in the format described. There is no need to check.

### Output Data

The result should be printed on the console as a sequence of strings, **arranged in alphabetical order**. Each string must be separated from the next one by a single space. If the weight of any of the 5 letter strings does not exist within the specified range, print "**No**".

### Constraints

* Numbers for **start** and **end** are integers in the range [**-10000 … 10000**].
* Allowed program time: 0.25 seconds.
* Allowed memory: 16 MB.

### Sample Input and Output

| Input     | Output       | Comments                                 |
| -------- | ----------- | ---------------------------------------- |
| 40<br>42 | bcead bdcea | weight("bcead") = 41<br>weight("bdcea") = 40 |

| Input    | Output                                    |
| ------- | ---------------------------------------- |
| -1<br>1 | bcdea cebda eaaad eaada eaadd eaade eaaed eadaa eadad eadae eadda eaddd eadde eadea eaded eadee eaead eaeda eaedd eaede eaeed eeaad eeada eeadd eeade eeaed eeead |

| Input       | Output                                    |
| ---------- | ---------------------------------------- |
| 200<br>300 | baadc babdc badac badbc badca badcb badcc badcd baddc bbadc bbdac bdaac bdabc bdaca bdacb bdacc bdacd bdadc bdbac bddac beadc bedac eabdc ebadc ebdac edbac |

| Input       | Output |
| ---------- | ----- |
| 300<br>400 | No    |

### Hints and Guidelines

Like every problem, we start the solution by **reading and processing the input data**:

![](/assets/chapter-9-1-images/03.Five-special-letters-01.png)

We have several main points in the problem – **generating all combinations** with a length of 5 including the 5 letters, **removing repeating letters**, and **calculating weight** for a simplified word. The answer will consist of every word whose weight is within the given range **`[firstNumber, secondNumber]`**.

#### Generating All Combinations

To generate **all combinations with a length of 1** using 5 symbols, we would use a **loop from 0..4**, as we want each number of the loop to match one character. To generate **any combinations of length 2** using 5 characters (i.e. "aa", "ab", "ac", …, "ba", …), we would create **two nested loops each running through the digits from 0 to 4**, as we will once again make sure that each digit matches a specific character. We will repeat this step 5 times, so we will finally have 5 nested loops with indexes **`i1`**, **`i2`**, **`i3`**, **`i4`**, and **`i5`**:

![](/assets/chapter-9-1-images/03.Five-special-letters-02.png)

Now that we have all 5-digit combinations, we must find a way to "turn" the five digits into a word with the letters from '`a`' to '`e`'. One of the ways to do that is to **predefine a simple string that contains the letters** that we have:

![](/assets/chapter-9-1-images/03.Five-special-letters-03.png)

**For each digit, we take the letter from the particular position.** This way, the number **00000** will become **"aaaaa"**, and the number **02423** will become **"acecd"**. We can create the 5-letter string in the following way:

![](/assets/chapter-9-1-images/03.Five-special-letters-04.png)

**Another way:** we can convert the digits to letters by using their arrangement in the **ASCII table**. The expression **`String.fromCharCode('a'.charCodeAt(0) + i)`** return the result **`'a'`** in case **`i = 0`**, **`'b'`** in case **`i = 1`**, **`'c'`** in case **`i = 2`**, etc.

This way we already have generated all 5-letter combinations and can proceed with the following part of the task.

***Attention:*** as we have chosen a **`pattern`** that takes into consideration the alphabetical arrangement of the letters, and cycles are run appropriately, the algorithm will generate the works in alphabetical order and there is no need for additional sorting before printing the output.

#### Removing Repetitive Letters

Once we have the finished string, we have to remove all the repeating symbols. We will do this by adding **the letters from left to right in a new string and each time before adding a letter, we will check if it already exists** – if it does, we will skip it and if it doesn't, we will add it. To begin with, we will add the first letter to the starting string:

![](/assets/chapter-9-1-images/03.Five-special-letters-05.png)

Then we will do the same with the other 4, checking each time with the following condition and the **`indexOf(…)`** method. This can be done with a loop by **`fullWord`** (leaving it to the reader for exercise), and it can be done lazily by copy-paste:

![](/assets/chapter-9-1-images/03.Five-special-letters-06.png)

The **`.indexOf(…)`** method returns **the index of the particular element if it is found or** **`-1`** **if the item is not found**. Therefore, every time we get **`-1`**, it means that we still do not have this letter in the new string with unique letters and we can add it, and if we get a value other than **`-1`**, this will mean we already have the letter and we'll not add it.

#### Calculating Weight

Calculating the weight is simply **going through the unique word** (**`word`**) obtained in the last step, and for each letter, we need to take its weight and multiply it by the position. For each letter, we need to calculate what value we will multiply its position by, for example by using a **`switch`** construction:

![](/assets/chapter-9-1-images/03.Five-special-letters-07.png)

Once we have the value of that letter, we should **multiply it by its position**. Because the indexes in the string differ by 1 from the actual positions, i.e. index 0 is position 1, index 1 is position 2, etc., we will add 1 to the indexes.

![](/assets/chapter-9-1-images/03.Five-special-letters-08.png)

All intermediate results obtained must be added to the **total amount for each letter of the 5-letter combination**.

#### Preparing The Output

Whether a word needs to be printed is determined by its weight. We need a condition to determine if **the current weight is in the range** [**start … end**] passed to the input at the start of the program. If this is the case, we print the **full** word (**`fullWord`**).

**Be careful** not to print the word with unique letters. It was only needed to calculate the weight!

The words are **separated with a space** and we'll accumulate them in an intermediate variable **`result`**, which is defined as an empty string at the beginning:

![](/assets/chapter-9-1-images/03.Five-special-letters-09.png)

#### Final Touches

The condition is met **unless we do not have a single word in the entered range**. To find out if we have found a word, we can simply check whether the string **`result`** has its initial value (i.e., an empty string), if it does, we print **`No`**, otherwise we print the whole string without the last space (using the **`.trim(…)`** method):

![](/assets/chapter-9-1-images/03.Five-special-letters-10.png)

### Testing in The Judge System

Test your solution here: [https://judge.softuni.org/Contests/Practice/Index/941#2](https://judge.softuni.org/Contests/Practice/Index/941#2).
